<!DOCTYPE html>
<meta charset="utf-8">
<style>

body{
  margin:0;
  top:0;
  left:0;
  overflow:hidden;
  /*background-color: #ededed;*/
}

input.edit-title{
  width:260px;
  color: blue;
  border:none;
  border-bottom: 1px black solid;
  font-family: Source Sans Pro;
  font-size: 16px;
  font-weight:800;
  text-transform: uppercase;
  background-color: transparent;
}

input.edit-title:focus{
  color: black;
  outline: none;
}

textarea.edit-description{
  color:black;
  font-size:16px;
  font-family: Source Sans Pro;
  font-weight: 400;
  background-color: white;
  resize: vertical;
}

textarea.edit-description:focus{
  border:1px black solid;
  outline: none;
}

.links line {
  stroke: #999;
  stroke-opacity: 1;
}

.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}

.node text {
  pointer-events: none;
  font: 10px sans-serif;
}

.labels{
  pointer-events: none;
}

.buttons {
  background-image: url("public/media/button-border.png");
  background-size: 40px 40px;
  background-color: rgba(255,255,255,0.9);
}

.secondary-buttons {
 /* background-image: url("public/media/button-border.png");
  background-size: 40px 40px;
  background-color: rgba(255,255,255,0.7);*/
  border: 1px dotted black;
  background-color: rgba(255,255,255,0.9);
}

.noselect {
  -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none; /* Chrome/Safari/Opera */
     -khtml-user-select: none; /* Konqueror */
       -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently
                                  not supported by any browser */
}

</style>
<script type="text/javascript" src="http://code.jquery.com/jquery-1.9.1.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,200i,300,300i,400,400i,600,600i,700,700i,900,900i" rel="stylesheet">
<script src="public/js/rhizoma.js"></script>
<script src="public/js/rhizomaGui.js"></script>
<script src="public/js/rhizomaStyle.js"></script>
<script src="public/js/rhizomaCommunicator.js"></script>
<script src="public/js/gui.js"></script>
<body>
<svg id="rhizoma" width="960" height="600" style="position:absolute;top:0px"></svg>
</body>
<script src="https://d3js.org/d3.v4.min.js"></script>
<!-- <script src="https://d3js.org/d3.v4.js"></script> -->
<script>

  /* INIT */

var $ = new Gui();
var gui = new RhizomaGui($);
var structure = new Rhizoma();
var rst = new RhizomaStyle();

var current_node = {};
var current_link = {};
var link_to_add = {};
    link_to_add.source = null;
    link_to_add.target = null;

var element =  document.getElementById("rhizoma"); 
    element.setAttribute("width", window.innerWidth);
    element.setAttribute("height", window.innerHeight);

var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");

var color = d3.scaleOrdinal(d3.schemeCategory20);

var simulation = d3.forceSimulation()
    .velocityDecay(0.1)
    .force("link", d3.forceLink().id(function(d) { return d.id; })/*.strength(function(d){return 0.5 / Math.min(d.source.size, d.target.size);})*/.distance(function(d){return 60;}))
    .force("charge", d3.forceManyBody()/*.strength(function(d){return -200;})*/)
    .force("center", d3.forceCenter(width / 2, height / 2));

var min_zoom = 0.1,
    max_zoom = 7,
    zoom = d3.zoom().scaleExtent([min_zoom,max_zoom]);
var go_to_center = false;
var run_translate = false;
var stop_simulation = false;

var reveal_labels = false;
var previous_reveal_labels = false;

var node;
var link;
var path;
var label;
var graph;
var map;

var inside_node = undefined;
var drift = [];

gui.menu();

d3.json("public/json/test.json", function(error, in_graph) {
  if (error) throw error;

  structure.setJSON(in_graph);
  graph = structure.getGraph();

  map = svg.append("rect")
  .attr("class", "map")
  .attr("id","rhizo")
  .attr("width",window.innerWidth)
  .attr("height",window.innerHeight)
  .attr("fill","transparent")
  .on("mousedown", mouseDownEnvironment)
  .on("mousemove", environmentMove);

  /* LINKS */

  rst.setEnvironment(inside_node,structure);
  link = svg.append("g")
    .attr("class", "links")
    .selectAll("line")
    .data(graph.links)
    .enter().append("line")
    .attr("id",function(d){return "the-line-"+d.id;})
    // .style("marker-end",  "url(#suit)")
    .attr("stroke-width", rst.linkStrokeWidth)
    .attr("stroke-dasharray", rst.linkStrokeDash)
    .style("stroke-linecap", "round")
    .style("stroke", rst.linkStroke);

  select_link = svg.append("g")
  .attr("class","select-links")
  .selectAll("line").filter(".select-link")
  .data(graph.links)
  .enter()
  .append("line")
  .attr("class","select-link")
    .attr("id",function(d){return "line-"+d.id;})
    .on("mouseover", mouseOverLink)
    .on("mouseout", mouseOutLink)
    .on("mousedown", mouseDownLink)
    .attr("stroke-width", "10px")
    .attr("stroke-dasharray", "0,0")
    .style("stroke-linecap", "round")
    .style("stroke","transparent");

  /* NODES */

  node = svg.append("g")
    .attr("class", "nodes")
    .attr("id","all-nodes")
    .selectAll("g")
    .data(graph.nodes)
    .enter()
    .append("svg:g")
    .attr("class","node")
    .attr("id",function(d){return "node-"+d.id;})
    .on("mouseover", mouseOverNode)
    .on("click", clickNode)
    .on("mouseout", mouseOutNode)
    .on('dblclick', mouseDoubleClick)
    .call(d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended));  
  
  path = node.append("path")
    .attr("id", function(d){return "node-symbol-"+d.id})
    .attr("class", "path")
    .attr("d", d3.symbol()
    .size(rst.nodeSize)
    .type(rst.nodeType))
    .style("stroke-linejoin", rst.nodeLineJoin)
    .style("stroke",rst.nodeStroke)
    .style("stroke-width",rst.nodeStrokeWidth)
    .attr("fill", rst.nodeFill);

  /* LABELS */

  label = svg.append("g")
    .attr("class", "labels")
    .selectAll("g")
    .data(graph.nodes)
    .enter()
    .append("svg:g")
    .attr("id",function(d){return "labels-"+d.id;});

  label.append("svg:text")
    .attr("class","noselect")
    .attr("id",function(d){return "label-"+d.id;})
    .attr("x",0)
    .attr("y",rst.labelTextY)
    .style("font-family","Source Sans Pro")
    .attr("text-anchor","middle")
    .style("font-size", rst.labelTextFontSize)
    .text(rst.labelText);

  label.append("rect")
    .attr("id", function(d){return "rect-"+d.id;})
    .attr("class","label-rect")
    .attr("x", rst.labelRectX)
    .attr("y", rst.labelRectY)
    .attr("width", function(d){return document.getElementById("label-"+d.id).getBBox().width+10;})
    .attr("height", function(d){return document.getElementById("label-"+d.id).getBBox().height+6;})
    .style("fill", "white")
    .style("opacity", rst.labelRectOpacity)
    .style("stroke-opacity","1")
    .style("stroke",rst.labelRectStroke)
    .attr("stroke-dasharray",rst.labelRectStrokeDash)
    .style("stroke-linecap", "round")
    .style("stroke-width",1);

  label.selectAll("text").remove();
  label.append("svg:text")
    .attr("class","noselect")
    .attr("id",function(d){return "label-"+d.id;})
    .attr("x",0)
    .attr("y", rst.labelTextY)
    .attr("fill", rst.labelTextFill)
    .style("font-family","Source Sans Pro")
    .attr("text-anchor","middle")
    .style("font-weight",rst.labelTextFontWeight)
    .style("font-size",rst.labelTextFontSize)
    .style("opacity",rst.labelTextOpacity)
    .text(rst.labelText);

  /* SIMULATION */

  simulation
      .nodes(graph.nodes)
      .on("tick", ticked);

  simulation.force("link")
      .links(graph.links);

  /* ZOOM */

  zoom.filter(function() { return !event.button && event.type !== 'dblclick'; }).on("zoom", function() {
    gui.hideControlPanel();
    if(document.getElementById("node-symbol-"+current_node.id) != null){
      if(inside_node != current_node.id){
        if(current_node.type != "buraco"){
          if(current_node.collapse != 0){
            document.getElementById("node-symbol-"+current_node.id).style.stroke = "transparent";
            document.getElementById("node-symbol-"+current_node.id).style.strokeWidth = "0px";
          }
          else{
            document.getElementById("node-symbol-"+current_node.id).style.stroke = color(current_node.group);
            document.getElementById("node-symbol-"+current_node.id).style.strokeWidth = "2px";
          }
        }
        else{
          document.getElementById("node-symbol-"+current_node.id).style.stroke = color(current_node.group);
          document.getElementById("node-symbol-"+current_node.id).style.strokeWidth = "2px";
        }
      }
      current_node = {};
    }
    var reference_element = svg.select(".nodes").attr("transform");//d3.select("g").node();
    var reference_transform = null;
    var scale = null;
    if(reference_element != null){
      reference_transform = reference_element.split(" ");
      scale = reference_transform[1].substring(reference_transform[1].indexOf("(")+1, reference_transform[1].indexOf(")"));
    }
    if(scale > 1.8){
      reveal_labels = true;
      revealLabels();
    }
    else{
      reveal_labels = false;  
      revealLabels(); 
    }
    d3.selectAll("g").filter(".labels, .nodes, .links, .select-links, .create-link").attr("transform", d3.event.transform);
  });
   
  svg.call(zoom);   

  function revealLabels(){
    if(reveal_labels != previous_reveal_labels){
      if(reveal_labels){
        var label_opacity = svg.selectAll("text").transition().style("opacity",rst.labelTextZoomOpacity).style("fill",rst.labelTextZoomFill);
        var label_styles = svg.selectAll("text").style("font-size",rst.labelTextZoomFontSize).attr("y", rst.labelTextZoomY).attr("x", rst.labelTextZoomX).attr("text-anchor",rst.labelTextZoomTextAnchor);
        // var rect_opacity = svg.selectAll("text").attr("opacity",function(d){console.log(d);return 1;});
        // var label_rect_opacity = svg.selectAll("rect").filter(".label-rect").style("opacity",rst.labelRectZoomOpacity);
      }
      else{
        var label_opacity = svg.selectAll("text").transition().style("opacity",rst.labelTextOpacity).style("fill",rst.labelTextFill).on("end", labelStyleTransition);
        // var label_rect_opacity = svg.selectAll("rect").filter(".label-rect").style("opacity",rst.labelRectOpacity);
      }
      previous_reveal_labels = reveal_labels;
    }
    //     simulation = d3.forceSimulation()
    //   .velocityDecay(0.1)
    //   .force("link", d3.forceLink().id(function(d) { return d.id; })/*.strength(function(d){return 0.5 / Math.min(d.source.size, d.target.size);})*/.distance(function(d){return 60;}))
    //   .force("charge", d3.forceManyBody()/*.strength(function(d){return -200;})*/)
    //   .force("center", d3.forceCenter(width / 2, height / 2));
    //   simulation
    //     .nodes(graph.nodes)
    //     .on("tick", ticked);
    // simulation.force("link")
    //     .links(graph.links);
  }

  function labelStyleTransition(){
    var label_styles = svg.selectAll("text").style("font-size",rst.labelTextFontSize).attr("y", rst.labelTextY).attr("x", 0).attr("text-anchor","middle");
  }

  function ticked() {
    node

        .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

    link
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    select_link
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });
        
    label
      .attr("transform",function(d){
        var offset_x = d.x;
        var offset_y = d.y;
        return "translate(" + offset_x + "," + offset_y + ")";
      });

    if(link_to_add.source != null){
      if(document.getElementById("select-lines")!=null){
        var source_node = svg.select("#node-"+link_to_add.source);
        var source_node_transform = source_node.attr("transform");
        var pass_translate = source_node_transform.substring(source_node_transform.indexOf("(")+1, source_node_transform.indexOf(")")).split(",");
        var selecting_line = svg.selectAll("#select-line")
        .attr("x1",pass_translate[0])
        .attr("y1",pass_translate[1]);
      }
    }
  }
});


  /* DRAG */

function dragstarted(d) {
  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
  if(!reveal_labels){
    document.getElementById("labels-"+d.id).style.display = "none";
  }
  else{
    if(d.type === "categoria" || d.parentConnections === 0){
      document.getElementById("labels-"+d.id).style.display = "none";
    }
    else{
      var innerhtml = document.getElementById("label-"+d.id).innerHTML;
      innerhtml = innerhtml.toUpperCase();
      document.getElementById("label-"+d.id).innerHTML = innerhtml;
      document.getElementById("label-"+d.id).style.fontWeight = 800;
    }
  }
}

function dragged(d) {
  if(link_to_add.source != null){
    if(document.getElementById("select-lines")!=null){
      var reference_element = d3.select("g").node();
      var mouse_xy = d3.mouse(reference_element);
      var source_node = svg.select("#node-"+link_to_add.source);
      var source_node_transform = source_node.attr("transform");
      var pass_translate = source_node_transform.substring(source_node_transform.indexOf("(")+1, source_node_transform.indexOf(")")).split(",");
      var selecting_line = svg.selectAll("#select-line")
      .attr("x1",pass_translate[0])
      .attr("y1",pass_translate[1])
      .attr("x2",mouse_xy[0])
      .attr("y2",mouse_xy[1]);
    }
  }
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function dragended(d) {
  // if(!stop_simulation){
    if (!d3.event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  // }
  // else{
    if(stop_simulation)
    simulation.stop();
  // }
   document.getElementById("labels-"+d.id).style.display = "inline";
   if(reveal_labels){
     if(d.type != "categoria" && d.parentConnections != 0){
        document.getElementById("label-"+d.id).innerHTML = d.name;
        document.getElementById("label-"+d.id).style.fontWeight = 400;
      }
   }
}

  /* MOUSE BEHAVIOR > EDITING */

document.body.addEventListener("click", environmentStabilize, true);

function environmentMove(){
  if(link_to_add.source != null){
    if(document.getElementById("select-lines")!=null){
      var reference_element = d3.select("g").node();
      var mouse_xy = d3.mouse(reference_element);
      var source_node = svg.select("#node-"+link_to_add.source);
      var source_node_transform = source_node.attr("transform");
      var pass_translate = source_node_transform.substring(source_node_transform.indexOf("(")+1, source_node_transform.indexOf(")")).split(",");
      var selecting_line = svg.selectAll("#select-line")
      .attr("x1",pass_translate[0])
      .attr("y1",pass_translate[1])
      .attr("x2",mouse_xy[0])
      .attr("y2",mouse_xy[1]);
    }
    else{
      var reference_element = d3.select("g").node();
      var mouse_xy = d3.mouse(reference_element);
      var reference_transform = svg.select(".nodes");
      var pass_transform = "translate(0,0),scale(1)";
      if(reference_transform.attr("transform") != null){
        pass_transform = reference_transform.attr("transform");
      }
      var source_node = svg.select("#node-"+link_to_add.source);
      var source_node_transform = source_node.attr("transform");
      var pass_translate = source_node_transform.substring(source_node_transform.indexOf("(")+1, source_node_transform.indexOf(")")).split(",");
      var init_data = [];
      init_data[0] = {};

      var selecting_line = svg.append("g")
      .attr("class","create-link")
      .attr("id","select-lines")
      .attr("transform",pass_transform)
      .selectAll("line")
      .filter("#select-line")
      .data(init_data)
      .enter()
      .append("line")
      .attr("id","select-line")
      .attr("stroke-width", "1")
      .style("stroke-linecap", "round")
      .style("stroke", "black")
      .style("pointer-events","none");

      var the_line = svg.select("#select-line")
      .attr("x1",pass_translate[0])
      .attr("y1",pass_translate[1])
      .attr("x2",mouse_xy[0])
      .attr("y2",mouse_xy[1]);
    }
  }
}

function centerEnvironment(){
  if(inside_node === undefined){
    zoomReset();
  }
  else{
    var index = undefined;
    for(var i = 0; i < graph.nodes.length; i++){
      if(inside_node === graph.nodes[i].id){
        index = i;
      }
    }
    if(index != undefined){
      zoomUpdate(graph.nodes[index].x, graph.nodes[index].y);
    }
  }
}

function cancelEdit(){
    if(link_to_add != null){
      link_to_add.source = null;
      link_to_add.target = null;
      gui.removeSelectLine();
      toggleLinkSelection(true);
    }
    // gui.closeMenus();
  }

function environmentStabilize(){
  if(gui.editionMode() != undefined && inside_node === undefined){
    if(gui.editionMode() === "environmentstabilize"){
      var update_nodes = svg.selectAll("g").filter(".node").each(function(d){structure.updateNodeXY(d);});
      var update_links = svg.selectAll("line").each(function(d){structure.updateLinkXY(d);});
      gui.closeMenus();
    }
    else if(gui.editionMode() === "environmentstop"){
      stop_simulation = !stop_simulation;
      simulation.stop();
      gui.closeMenus();
    }
    else if(gui.editionMode() === "environmentcenter"){
      centerEnvironment();
      gui.closeMenus();
    }
    else if(gui.editionMode() === "cancellink"){
      cancelEdit();
    }
  }
  else if(gui.editionMode() != undefined && inside_node != undefined){
    if(gui.editionMode() === "environmentcenter"){
      centerEnvironment();
      gui.closeMenus();
    }
  }
  else if(gui.saveNode() != false){
    structure.updateNode(gui.saveNode());
    var this_id = gui.saveNode().id;
    gui.resetCurrentEditing();
    restart();
    rst.setEnvironment(inside_node,structure);
    rst.updateLabel(this_id);
  }
  else if(gui.saveLink() != false){
    var source_id = gui.saveLink().source;
    var target_id = gui.saveLink().target;
    structure.updateLink(gui.saveLink());
    structure.updateGraph();
    gui.resetCurrentEditing();
    restart();
    rst.setEnvironment(inside_node,structure);
    rst.updateLabel(source_id);
    rst.updateLabel(target_id);
  }

  if(gui.deleteLink() != undefined){
    var source_id = null;
    var target_id = null;
    for(var i = 0; i < graph.links.length;i++){
      if(graph.links[i].id === gui.deleteLink()){
        source_id = graph.links[i].source.id;
        target_id = graph.links[i].target.id;
      }
    }
    structure.deleteLink(gui.deleteLink());
    gui.resetLink();
    gui.closeMenus();
    restart();
    rst.setEnvironment(inside_node,structure);
    rst.updateLabel(source_id);
    rst.updateLabel(target_id);
  }
}

function mouseDownEnvironment(){
  if(gui.editionMode() != undefined){
    if(gui.editionMode() === "nodeadd"){ 
      var transform = d3.select("g").node();
      var mouse_xy = d3.mouse(transform);
      var node_x = mouse_xy[0];
      var node_y = mouse_xy[1];
      structure.addNode(node_x,node_y);
      gui.closeMenus();
      restart();
    }
  }
}

  /* MOUSE BEHAVIOR > LINK */

function mouseOverLink(d){
  document.getElementById("line-"+d.id).style.cursor = "pointer";
  document.getElementById("the-line-"+d.id).style.strokeWidth = "4px";
}

function mouseOutLink(d){
  document.getElementById("the-line-"+d.id).style.strokeWidth = "1px";
}

function mouseDownLink(d){
  if(document.getElementById("node-symbol-"+current_node.id) != null){
    if(inside_node != current_node.id){
      if(current_node.type != "buraco"){
        if(current_node.collapse != 0){
          document.getElementById("node-symbol-"+current_node.id).style.stroke = "transparent";
          document.getElementById("node-symbol-"+current_node.id).style.strokeWidth = "0px";
        }
        else{
          document.getElementById("node-symbol-"+current_node.id).style.stroke = color(current_node.group);
          document.getElementById("node-symbol-"+current_node.id).style.strokeWidth = "2px";
        }
      }
      else{
        document.getElementById("node-symbol-"+current_node.id).style.stroke = color(current_node.group);
        document.getElementById("node-symbol-"+current_node.id).style.strokeWidth = "2px";
      }
    }
    current_node = {};
  }
  if(gui.editionMode() === "linkdelete"){
    structure.deleteLink(d.id);
    gui.closeMenus();
    restart();
  }
  else{
    if(current_link.id != d.id && document.getElementById("the-line-"+current_link.id) != null){
      current_link.id = d.id;
      gui.updateControlPanel(d,"LINK", false);
    }
    else if(current_link.id != d.id && document.getElementById("the-line-"+current_link.id) === null){
      current_link.id = d.id;
      gui.updateControlPanel(d, "LINK", false);
    }
    else{ // if(current_node === d.id)
      gui.hideControlPanel();
      current_link = {};
    }
  }
}

  /* MOUSE BEHAVIOR > NODE */

function mouseOverNode(d){
  if(link_to_add.source != null){
    if(document.getElementById("select-lines")!=null){
      var reference_element = d3.select("#node-"+d.id);
      var reference_element_transform = reference_element.attr("transform");
      var pass_reference_translate = reference_element_transform.substring(reference_element_transform.indexOf("(")+1, reference_element_transform.indexOf(")")).split(",");
      var source_node = svg.select("#node-"+link_to_add.source);
      var source_node_transform = source_node.attr("transform");
      var pass_translate = source_node_transform.substring(source_node_transform.indexOf("(")+1, source_node_transform.indexOf(")")).split(",");
      var selecting_line = svg.selectAll("#select-line")
      .attr("x1",pass_translate[0])
      .attr("y1",pass_translate[1])
      .attr("x2",pass_reference_translate[0])
      .attr("y2",pass_reference_translate[1]);
    }
  }
 // var current_node = d.id;
  // if(d.size <= 8){
  document.getElementById("label-"+d.id).style.opacity="1";
  // }
  svg.style("cursor","pointer");
  if(inside_node != d.id){
    if(d.collapse === 1){
      if(d.standby === 0){
        document.getElementById("node-symbol-"+d.id).style.stroke = d3.rgb(color(d.group)).darker(1);
        document.getElementById("node-symbol-"+d.id).style.strokeWidth = "2px";
      }
      else{
        document.getElementById("node-symbol-"+d.id).style.stroke = d3.rgb("#c9c9c9").darker(1);
        document.getElementById("node-symbol-"+d.id).style.strokeWidth = "2px";
      }
    }
    else{
      if(d.standby === 0){
        document.getElementById("node-symbol-"+d.id).style.stroke = d3.rgb(color(d.group)).darker(1);
        document.getElementById("node-symbol-"+d.id).style.strokeWidth = "4px";
      }
      else{
        document.getElementById("node-symbol-"+d.id).style.stroke = d3.rgb("#c9c9c9").darker(1);
        document.getElementById("node-symbol-"+d.id).style.strokeWidth = "4px";
      }
    }
  }
  else{
    document.getElementById("node-symbol-"+d.id).style.strokeWidth = "4px";
  }
}

function mouseOutNode(d){
  svg.style("cursor","default");
  var opacity = 0;
  if(reveal_labels){
    if(d.type === "categoria" || d.parentConnections === 0){
      opacity = 0.8;
    }
    else if(d.standby === 1){
      opacity = 0;
    }
    else{
      opacity = 1;
    }
  }
  else{
    if(d.parentConnections === 0 && d.childConnections > 0){
      opacity = 1;
    }
    else if(d.type === "categoria"){
      opacity = 1;
    }
  }
  
  document.getElementById("label-"+d.id).style.opacity= opacity;

  if(inside_node != d.id){
    if(current_node.id != d.id && document.getElementById("node-symbol-"+d.id) != null){
      if(d.collapse === 1){
        if(d.type != "buraco"){
          document.getElementById("node-symbol-"+d.id).style.stroke = "transparent";
          document.getElementById("node-symbol-"+d.id).style.strokeWidth = "0px";
        }
        else{
          document.getElementById("node-symbol-"+d.id).style.stroke = color(d.group);
          document.getElementById("node-symbol-"+d.id).style.strokeWidth = "2px";
        }
      }
      else{
        if(d.standby === 0){
          document.getElementById("node-symbol-"+d.id).style.stroke = color(d.group);
          document.getElementById("node-symbol-"+d.id).style.strokeWidth = "2px";
        }
        else{
          document.getElementById("node-symbol-"+d.id).style.stroke = "#c9c9c9";
          document.getElementById("node-symbol-"+d.id).style.strokeWidth = "2px";
        }
      }
    }
  }
  else{
    document.getElementById("node-symbol-"+d.id).style.strokeWidth = "2px";
  }
}

function clickNode(d){
  if(gui.editionMode() != "nodedelete" && gui.editionMode() != "linkadd" && gui.editionMode() != "stateexplode" && gui.editionMode() != "statecontract" && gui.editionMode() != "stateidle"){
    if(current_node.id != d.id && document.getElementById("node-symbol-"+current_node.id) != null){
      if(inside_node != current_node.id){
        if(current_node.type != "buraco"){
          if(current_node.collapse != 0){
            document.getElementById("node-symbol-"+current_node.id).style.stroke = "transparent";
            document.getElementById("node-symbol-"+current_node.id).style.strokeWidth = "0px";
          }
          else{
            document.getElementById("node-symbol-"+current_node.id).style.stroke = color(current_node.group);
            document.getElementById("node-symbol-"+current_node.id).style.strokeWidth = "2px";
          }
        }
        else{
          document.getElementById("node-symbol-"+current_node.id).style.stroke = color(current_node.group);
          document.getElementById("node-symbol-"+current_node.id).style.strokeWidth = "2px";
        }
      }
      current_node.id = d.id;
      current_node.group = d.group;
      current_node.type = d.type;
      current_node.collapse = d.collapse;
      current_node.standby = d.standby;
      var in_links = structure.getLinks(d);
      for(var i = 0; i < in_links.length; i++){
        for(var j = 0; j < graph.links.length; j++){
          if(in_links[i].id === graph.links[j].id){
            in_links[i].source.group = graph.links[j].source.group;
            in_links[i].target.group = graph.links[j].target.group;
          }
        }
      }
      gui.setAllLinks(in_links);
      gui.updateControlPanel(d,"NODE", false);
    }
    else if(current_node.id != d.id && document.getElementById("node-symbol-"+current_node.id) === null){
      current_node.id = d.id;
      current_node.group = d.group;
      current_node.type = d.type;
      current_node.collapse = d.collapse;
      current_node.standby = d.standby;
      var in_links = structure.getLinks(d);
      for(var i = 0; i < in_links.length; i++){
        for(var j = 0; j < graph.links.length; j++){
          if(in_links[i].id === graph.links[j].id){
            in_links[i].source.group = graph.links[j].source.group;
            in_links[i].target.group = graph.links[j].target.group;
          }
        }
      }
      gui.setAllLinks(in_links);
      gui.updateControlPanel(d, "NODE", false);
    }
    else{ // if(current_node === d.id)
      gui.hideControlPanel();
      current_node = {};
    }
  }
  else if(gui.editionMode() === "nodedelete"){
    var these_links = structure.getLinks(d);
    var update_nodes = [];
    for(var i = 0; i < these_links.length; i++){
      if(these_links[i].source.id === d.id){
        update_nodes.push(these_links[i].target.id);
      }
      else{
        update_nodes.push(these_links[i].source.id);
      }
    }
    gui.hideControlPanel();
    current_node = {};
    structure.deleteNode(d.id);
    gui.closeMenus();
    restart();
    rst.setEnvironment(inside_node,structure);
    for(var i = 0; i < update_nodes.length; i++){
      rst.updateLabel(update_nodes[i]);
    }
  }
  else if(gui.editionMode() === "linkadd"){
    if(link_to_add.source === null){
      link_to_add.source = d.id;
      toggleLinkSelection(false);
    }
    else if(link_to_add.source != null && link_to_add.source != d.id){
      link_to_add.target = d.id;
      structure.addLink(link_to_add);
      link_to_add.source = null;
      link_to_add.target = null;
      gui.closeMenus();
      gui.updateControlPanel(structure.getNode(d), "NODE", true);
      restart();
      rst.setEnvironment(inside_node,structure);
      rst.updateLabel(d.id);
      gui.removeSelectLine();
    }
  }
  else if(gui.editionMode() === "stateexplode"){
    structure.collapseNode(d.id);
    gui.closeMenus();
    restart();
  }
  else if(gui.editionMode() === "statecontract"){
    structure.closeNode(d.id);
    gui.closeMenus();
    restart();
  }
  else if(gui.editionMode() === "stateidle"){
    structure.toggleNodeStandby(d);
    gui.closeMenus();
    restart();
  }
}

function toggleLinkSelection(check_link_selection){
  if(!check_link_selection){
    var links = svg.selectAll(".select-link").style("pointer-events","none");
  }
  else{
    var links = svg.selectAll(".select-link").style("pointer-events","all");
  }
}

function mouseDoubleClick(d){
  run_translate = true;
  if(d.id != inside_node){       // increase one level on navigation (enter node)
    structure.navigateRhizomaEnter(d.id);
    inside_node = d.id;
    drift[drift.length] = d.id;
    restart(d); 
  }
  else if(d.id === inside_node){ // decreases one level on navigation (exit node [click on inside_node])
    if(d.parentConnections > 0){
      structure.navigateRhizomaExitCheck(drift[drift.length-2]);
      drift.pop();
      inside_node = drift[drift.length-1];
      if(drift.length === 0){
        go_to_center = true;
      }
    }
    else{ // back to root if level-1 = primary
      structure.navigateRoot();
      drift = [];//.pop();
      inside_node = undefined;
      go_to_center = true;
    }
    // drift.pop();
    // inside_node = drift[drift.length-1];
    restart(d);
  }
  else{                          // back to root if there is an error
    structure.navigateRoot();
    drift = [];//.pop();
    inside_node = undefined;
    go_to_center = true;
    restart(d);
  }
}

  /* UPDATE GRAPH FUNCTIONS */

function restart(e){
  graph = structure.getGraph();

  rst.setEnvironment(inside_node,structure);
  node = node.data(graph.nodes, function(d){return d.id});
  node.selectAll("path").remove();
  node.exit().remove();

  node = node.enter()
    .append("svg:g")
    .attr("class","node")
    .attr("id",function(d){ return "node-"+d.id;})
    .on("mouseover", mouseOverNode)
    .on("click", clickNode)
    .on("mouseout", mouseOutNode)
    .on('dblclick', mouseDoubleClick)
    .call(d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended))
    .merge(node);  

  path = node.append("path")
    .attr("id", function(d){return "node-symbol-"+d.id})
    .attr("d", d3.symbol()
    .size(rst.nodeSize)
    .type(rst.nodeType))
    .style("stroke-linejoin",rst.nodeLineJoin)
    .style("stroke",rst.nodeStroke)
    .style("stroke-width",rst.nodeStrokeWidth)
    .attr("fill",rst.nodeFill);

  link = link.data(graph.links, function(d) { return d.source + "-" + d.target; });
  link.exit()
      .remove();

  link = link.enter()
    .append("line")
    .attr("id",function(d){return "the-line-"+d.id;})
    .attr("stroke-width", rst.linkStrokeWidth)
    .attr("stroke-dasharray", rst.linkStrokeDash)
    .style("stroke-linecap", "round")
    .style("stroke", rst.linkStroke)
    .merge(link);

  select_link = select_link.data(graph.links, function(d) { return d.source + "-" + d.target; });
  select_link.exit()
      .remove();

  select_link = select_link.enter()
  .append("line")
  .attr("class","select-link")
    .attr("id",function(d){return "line-"+d.id;})
    .on("mouseover", mouseOverLink)
    .on("mouseout", mouseOutLink)
    .on("mousedown", mouseDownLink)
    .attr("stroke-width", "10px")
    .attr("stroke-dasharray", "0,0")
    .style("stroke-linecap", "round")
    .style("stroke", "transparent")
    .merge(select_link);

  label = label.data(graph.nodes, function(d){return d.id;});
  label.selectAll("rect").remove();
  label.exit().remove();

  label = label.enter()
    .append("svg:g")
    .attr("id",function(d){return "labels-"+d.id;}).merge(label);

  label.append("svg:text")
    .attr("class","noselect")
    .attr("id",function(d){return "label-"+d.id;})
    .attr("x",0)
    .attr("y",rst.labelTextY)
    .style("font-family","Source Sans Pro")
    .attr("text-anchor","middle")
    .style("font-size", rst.labelTextFontSize)
    .text(rst.labelText);

  label.append("rect")
    .attr("id", function(d){return "rect-"+d.id;})
    .attr("x", rst.labelRectX)
    .attr("y", rst.labelRectY)
    .attr("width", function(d){return document.getElementById("label-"+d.id).getBBox().width+10;})
    .attr("height", function(d){return document.getElementById("label-"+d.id).getBBox().height+6;})
    .style("fill", "white")
    .style("opacity", rst.labelRectOpacity)
    .style("stroke-opacity","1")
    .style("stroke",rst.labelRectStroke)
    .attr("stroke-dasharray",rst.labelRectStrokeDash)
    .style("stroke-linecap", "round")
    .style("stroke-width",1);

  label.selectAll("text").remove();

  if(reveal_labels){
    label.append("svg:text")
    .attr("class","noselect")
    .attr("id",function(d){return "label-"+d.id;})
    .attr("x",rst.labelTextZoomX)
    .attr("y", rst.labelTextZoomY)
    .attr("fill", rst.labelTextZoomFill)
    .style("font-family","Source Sans Pro")
    .attr("text-anchor",rst.labelTextZoomTextAnchor)
    .style("font-weight",rst.labelTextFontWeight)
    .style("font-size",rst.labelTextZoomFontSize)
    .style("opacity",rst.labelTextZoomOpacity)
    .text(rst.labelText);
  }
  else{
    label.append("svg:text")
    .attr("class","noselect")
    .attr("id",function(d){return "label-"+d.id;})
    .attr("x",0)
    .attr("y", rst.labelTextY)
    .attr("fill", rst.labelTextFill)
    .style("font-family","Source Sans Pro")
    .attr("text-anchor","middle")
    .style("font-weight",rst.labelTextFontWeight)
    .style("font-size",rst.labelTextFontSize)
    .style("opacity",rst.labelTextOpacity)
    .text(rst.labelText);
  }
  
  // Update and restart the simulation.
  simulation.nodes(graph.nodes); // + on tick?
  simulation.force("link").links(graph.links);
  if(run_translate){
    var transform = d3.select("g").node();
      var mouse_xy = d3.mouse(transform);
      var node_x = mouse_xy[0];
      var node_y = mouse_xy[1];
    if(go_to_center){
      simulation.force("center", d3.forceCenter(width/2,height/2));
      go_to_center = false;
      zoomReset();
    }
    else{
      simulation.force("center", d3.forceCenter(node_x,node_y));
        zoomUpdate(node_x,node_y);
    }
    run_translate = false;
  }
  
  simulation.alpha(1).restart();
  
}

  /* ZOOM */

function zoomUpdate(node_x,node_y){
  var dx = document.getElementById("all-nodes").getBBox().height;
  var dy = document.getElementById("all-nodes").getBBox().width;

  // guardar no drift o bounding box?
  scale = Math.max(1, Math.min(4, 0.8 / Math.max(dx / width, dy / height)));
  translate = [width / 2 - scale * node_x, height / 2 - scale * node_y];

  svg.transition()
      .duration(750)
      .call( zoom.transform, d3.zoomIdentity.translate(translate[0],translate[1]).scale(scale) );
}

function zoomReset(){
  svg.transition()
      .duration(750)
      .call( zoom.transform, d3.zoomIdentity );
}

</script>